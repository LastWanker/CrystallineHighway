本子项目负责对词向量空间与词频分布进行统计标定，
最终产出以下长期可复用参数：

1. distance_quantiles：
   若干距离分位数（如 10%, 30%, 50%, 70%, 90%），
   用于将“命中概率 p”映射为“典型容忍半径”。

2. avg_freq：
   全局词频分布的典型值（中位数），
   用于将词频映射为半径缩放因子。

主系统基于以上参数，定义容忍度函数：
R = distance_quantiles[p] * (avg_freq / word_freq)，
并在 [R_min, R_max] 范围内裁剪。

【最小可落地的“容忍度统一方案”（纯工程版）】

目标直觉（这是我们唯一关心的事）：

“的”这种超高频词：几乎永远不共用实例（基本每次新建）

极低频词：几乎全图通吃（稳定锚点）

典型词：在构建态，命中概率约 50%（这个比例可调）

我们只用三样东西：

向量之间的距离

词频

一个可调的“命中比例 p”（默认 0.5）

步骤 1：先不管词频，只看向量空间本身

做一件非常简单的事：

从词向量库里，随机抽很多词

随机抽很多“词对”

算它们之间的欧氏距离

取这些距离的中位数，记为 avg_dist

直觉解释：

avg_dist 表示：在这个空间里，“一般不相关的两个词”离多远

这是你整个空间的“尺度感”

我们不解释它是不是容忍度，它只是一个参考长度

步骤 2：再不管向量，只看词频

从你的 global_freq 里，拿所有词的频率

取频率的中位数，记为 avg_freq

直觉解释：

avg_freq 表示：一个“典型词”的常见程度

既不是“的”，也不是极冷门词

步骤 3：把“典型词”的容忍度钉死（这是核心）

我们现在拍一个非常明确、非常工程化的钉子：

对于“频率 = avg_freq 的词”，
在构建态，命中概率 = p（默认 50%）

怎么实现这个目标？

在“距离分布”里，找到一个半径 R_typical

使得：

落在这个半径内的概率 ≈ p

实现方式（不用数学理解）：

你已经有一堆“距离样本”

直接取它们的 p 分位数

这个值，就是 R_typical

直觉解释：

半径取这个值，刚好一半时间能命中，一半时间新建

步骤 4：让频率来“拉伸或压缩”这个半径

现在终于用上频率，但方式很粗暴、很直觉：

对每个词：

如果它比典型词更常见 → 半径缩小

如果它比典型词更少见 → 半径放大

最简单、完全够用的规则：

半径 = R_typical * (avg_freq / word_freq)

再加两个保险（必须要）：

半径不能小于 R_min（防止无限分身）

半径不能大于 R_max（防止全图通吃失控）

这套规则自然满足你的三个要求：

“的”：

word_freq 远大于 avg_freq

半径被压到非常小

几乎不可能命中 → 到处分身 → 不会被共用

极低频词：

word_freq 远小于 avg_freq

半径被拉得很大

基本全图命中 → 稳定锚点

典型词：

word_freq ≈ avg_freq

半径 ≈ R_typical

命中概率 ≈ p（默认 50%）

参数只有这几个（而且都很好调）：

p：典型词命中率（默认 0.5）

R_min：高频词最小容忍度

R_max：低频词最大容忍度